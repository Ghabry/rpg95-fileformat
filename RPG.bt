// *.RPG file contains audio settings, actors, map tree and maps

// ToDo: Most actor data, structure of map tree

typedef struct StrItem {
    int audio_type;
    local string t = ReadLine(FTell(), -1, false);
    char text[Strlen(t)];
    int unk;
    char unk3;
} audioitem <optimize=false>;

typedef struct Audio {
    StrItem walking;
    StrItem wagon;
    StrItem sled;
    StrItem boat;
    StrItem ship;
    StrItem balloon;
    StrItem airship;
    StrItem coobat_start;
    StrItem combat;
    StrItem victory;
    StrItem level_up;
    StrItem rest;
} audio_ <optimize=false>;

typedef struct Actor {
    int unk;
    int unk2;
    char name[18];
    short unk3;
    short level;
    char padding[902];
    char pad;
} actor <optimize=false>;

typedef struct Tile {
    local string t = ReadLine(FTell(), -1, false);
    char text[Strlen(t)];
    char cr;
} tile <optimize=false>;

typedef struct EncounterRate {
    uchar party;
    uchar rate; // From 0 to 200?
};

typedef struct MapEvent {
    short evt_id : 8; // File EVT%05d.DAT
    short meta : 7;
    // When MSB is 1, evt_id is the "gap size" (tiles w/o event)
    // on the map
    short skip : 1; 
};

typedef struct Map {
    int map_id;
    char map_name[18];
    char unk[7];
    int looping;
    char unk2[8];
    short width;
    short height;
    char map_tree[20]; // not sure
    EncounterRate enc_rate[10];
    Tile tilemap_names[4] <optimize=false>;
    short tiles[width * height]; // value = tile ID

    // Event parsing is tricky, why didn't they use width * height
    // The upper byte is metadata
    // The lower byte is the event number

    local short evt_cnt = 0;
    local short map_offset = 0;
    local short skip = 0;

    // All the ReadXXX commands don't alter the read-pos
    // Parse until "missing events" marker
    while ((short)((int)ReadUShort() - 0x7FFF - width * height + map_offset) != 0) {
        evt_cnt++;
        map_offset++;
        
        skip = (uchar)ReadByte();
        FSeek(FTell() + 1);
        if ((uchar)ReadByte()) {
            // Skip bit set, skip event "gap"
            map_offset += skip;
        }
        FSeek(FTell() + 1);
    }
    FSeek(FTell() - evt_cnt * 2);

    if (evt_cnt > 0) {
        MapEvent evt_tiles[evt_cnt];
    }
    // missing_events = 0x7FFF + "tiles w/o events until end of map"
    short missing_events;
} map <optimize=false>;

struct RPG {
    char header[30];
    char version;
    int unk;
    int unk2;
    Audio audio;
    int unk3;
    int unk4;
    char coin_name[21];
    short item_max;
    short unk5;
    short msg_speed;
    short game_options; // bit-field: 1 Window transp, 2 save enabled
    Actor actors[8];
    char unk7[200];
    int unk8;
    int start_map;
    int start_x;
    int start_y;
    Map maps[3] <optimize=false>; // dynamic, until EOF
} rpg;
