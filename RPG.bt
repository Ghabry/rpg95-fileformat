// *.RPG file contains audio settings, actors, map tree and maps

// ToDo: Some actor data, structure of map tree

typedef struct StrItem {
    int audio_type;
    local string t = ReadLine(FTell(), -1, false);
    char text[Strlen(t)];
    int unk;
    char unk3;
} audioitem <optimize=false>;

typedef struct Audio {
    StrItem walking;
    StrItem wagon;
    StrItem sled;
    StrItem boat;
    StrItem ship;
    StrItem balloon;
    StrItem airship;
    StrItem coobat_start;
    StrItem combat;
    StrItem victory;
    StrItem level_up;
} audio_ <optimize=false>;

typedef struct Actor {
    int actor_id; // 1 - 7
    int start_party_member; // 0 no, 1 yes
    char name[18];
    short unk;
    int start_level;
    int unk2[9];
    // all 0-100
    char power[100];
    char strength[100];
    char intelligence[100];
    char speed[100];
    char luck[100];
    // In the editor any of the 5 curves is a bezier with
    // 4 control points.
    // But this would be only 20 elements.
    // Probably not relevant for the Player, precalculated above
    int bezier[40];

    // Weapon, Armor, Shield, Helmet, Misc
    // -1 = no equip
    uchar equip[5];
    char magic_learn_level[100]; // 0 - 100
    char magic_damage[100]; // 0 - 100

    // How is experience and level up handled?
} actor <optimize=false>;

typedef struct Tile {
    local string t = ReadLine(FTell(), -1, false);
    char text[Strlen(t)];
    char cr;
} tile <optimize=false>;

typedef struct EncounterRate {
    uchar party;
    uchar rate; // From 0 to 200?
};

typedef struct MapEvent {
    short evt_id : 8; // File EVT%05d.DAT
    short meta : 7;
    // When MSB is 1, evt_id is the "gap size" (tiles w/o event)
    // on the map
    short skip : 1; 
};

typedef struct MapType {
    int looping : 1;
    int area : 1;
};

typedef struct Map {
    int map_id;
    char map_name[18];
    char unk[7];
    MapType map_type;
    int area_begin_x;
    int area_end_x;
    short width;
    short height;
    int parent_id;
    // ??? Editor only. Map disappears from tree when modified
    int tree_order;
    char unk2[4];
    // What is area exit point?
    int area_exit_x;
    int area_exit_y;
    EncounterRate enc_rate[10];

    if (map_type.area == 0) {
        Tile tilemap_names[4] <optimize=false>;
        short tiles[width * height]; // value = tile ID
    
        // Event parsing is tricky, why didn't they use width * height
        // The upper byte is metadata
        // The lower byte is the event number
    
        local short evt_cnt = 0;
        local short map_offset = 0;
        local short skip = 0;
    
        // All the ReadXXX commands don't alter the read-pos
        // Parse until "missing events" marker
        while ((short)((int)ReadUShort() - 0x7FFF - width * height + map_offset) != 0) {
            evt_cnt++;
            map_offset++;
            
            skip = (uchar)ReadByte();
            FSeek(FTell() + 1);
            if ((uchar)ReadByte()) {
                // Skip bit set, skip event "gap"
                map_offset += skip;
            }
            FSeek(FTell() + 1);
        }
        FSeek(FTell() - evt_cnt * 2);
    
        if (evt_cnt > 0) {
            MapEvent evt_tiles[evt_cnt];
        }
        // missing_events = 0x7FFF + "tiles w/o events until end of map"
        short missing_events;
    }
} map <optimize=false>;

struct RPG {
    char header[30];
    char version[5];
    int unk;
    Audio audio;
    // When version is < 0.98 audio contains only 11 elements!
    if (Atof(version) >= 0.98) {
        StrItem rest;
    }
    int unk3;
    int unk4;
    char coin_name[21];
    short item_max;
    short unk5;
    short msg_speed;
    short game_options; // bit-field: 1 Window transp, 2 save enabled
    Actor actors[8];
    // up to item_max items
    short start_items[100];
    int start_money;
    int start_map;
    int start_x;
    int start_y;
    Map maps[7] <optimize=false>; // dynamic, until EOF
} rpg;
